<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026 灵龟献瑞 - 镜头切换版</title>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <style>
        :root { --emerald: #00ffaa; --gold: #ffdf00; }
        body { margin: 0; overflow: hidden; background: #000; color: var(--gold); font-family: 'Cinzel', serif; }
        
        #ui-layer { position: fixed; inset: 0; pointer-events: none; z-index: 10; padding: env(safe-area-inset-top) 20px 40px 20px; transition: opacity 0.5s; }
        
        .main-title { font-size: 2.2rem; margin: 0; filter: drop-shadow(0 0 10px var(--emerald)); color: #fff; text-align: center; margin-top: 10vh; letter-spacing: 4px;}
        .sub-title { font-size: 0.75rem; letter-spacing: 4px; opacity: 0.8; text-align: center; margin-top: 8px; color: var(--gold); }

        .top-right-btns { position: absolute; top: env(safe-area-inset-top); right: 20px; pointer-events: auto; display: flex; gap: 10px; z-index: 100; margin-top: 10px;}
        .glass-btn { 
            background: rgba(255, 255, 255, 0.1); border: 1px solid var(--gold); color: var(--gold); 
            padding: 8px 15px; font-size: 12px; cursor: pointer; backdrop-filter: blur(5px); border-radius: 4px;
        }

        #video-container {
            position: absolute; bottom: 30px; right: 20px; width: 100px; height: 130px;
            border: 1px solid rgba(255, 223, 0, 0.3); border-radius: 8px; overflow: hidden;
            background: #111; pointer-events: auto; transition: opacity 0.5s, transform 0.3s;
        }
        /* 初始为前置镜像状态 */
        .mirror { transform: scaleX(-1); }
        #webcam { width: 100%; height: 100%; object-fit: cover; opacity: 0.5; }

        #start-mask {
            position: fixed; inset: 0; background: #000; z-index: 1000;
            display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center;
        }
        .start-btn {
            background: none; border: 1px solid var(--gold); color: var(--gold);
            padding: 12px 30px; font-size: 1rem; cursor: pointer; letter-spacing: 2px;
        }
        
        .hint-text { position: fixed; bottom: 40px; left: 0; width: 100%; text-align: center; font-size: 11px; opacity: 0.4; pointer-events: none; }
    </style>
</head>
<body>

    <div id="start-mask">
        <h2 style="color:white; font-weight: 400; letter-spacing: 3px;">2026 灵龟献瑞</h2>
        <p style="color:var(--gold); font-size: 12px; margin-bottom: 30px; opacity: 0.6;">极致灵敏手势交互</p>
        <button class="start-btn" onclick="startExperience()">开启体验</button>
    </div>

    <div class="top-right-btns">
        <button class="glass-btn" id="switch-btn" style="display:none;" onclick="toggleCamera()">切换镜头</button>
        <button class="glass-btn" id="fs-btn" style="display:none;" onclick="toggleCinemaMode()">全屏模式</button>
    </div>

    <div id="ui-layer">
        <div id="text-content">
            <h1 class="main-title">HAPPY 2026</h1>
            <h2 class="sub-title">祥瑞灵龟 · 岁岁平安</h2>
        </div>

        <div id="video-container" class="mirror">
            <video id="webcam" autoplay playsinline></video>
        </div>
        <div id="bottom-hint" class="hint-text">微动：全向旋转控制 | 握拳：聚合</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer, clock;
        let particles, handLandmarker, video;
        let currentMode = 'TREE';
        let isCinema = false;
        let currentFacingMode = 'user'; // 'user' 或 'environment'
        const count = 15000; 

        const PARAMS = {
            yOffset: 0, 
            scatterSize: 25, 
            lerpSpeed: 0.012
        };

        window.toggleCinemaMode = function() {
            isCinema = !isCinema;
            const ui = document.getElementById('text-content');
            const videoCont = document.getElementById('video-container');
            const hint = document.getElementById('bottom-hint');
            const btn = document.getElementById('fs-btn');

            ui.style.opacity = isCinema ? "0" : "1";
            videoCont.style.opacity = isCinema ? "0" : "1";
            hint.style.opacity = isCinema ? "0" : "0.4";
            btn.innerText = isCinema ? "退出全屏" : "全屏模式";
        };

        // 切换摄像头函数
        window.toggleCamera = async function() {
            currentFacingMode = (currentFacingMode === 'user') ? 'environment' : 'user';
            
            // 停止当前视频流
            if (video && video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
            }

            // 更新 UI 镜像状态
            const videoCont = document.getElementById('video-container');
            if (currentFacingMode === 'user') {
                videoCont.classList.add('mirror');
            } else {
                videoCont.classList.remove('mirror');
            }

            // 重新初始化摄像头
            await setupCamera();
        };

        window.startExperience = async function() {
            document.getElementById('start-mask').style.display = 'none';
            document.getElementById('fs-btn').style.display = 'block';
            document.getElementById('switch-btn').style.display = 'block';
            await init();
        }

        async function init() {
            clock = new THREE.Clock();
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 48);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(count * 3);
            const tar = new Float32Array(count * 3);
            const scat = new Float32Array(count * 3);
            const col = new Float32Array(count * 3);

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            for(let i=0; i<count; i++) {
                const end = getTurtlePoint(i);
                pos[i*3]=0; pos[i*3+1]=0; pos[i*3+2]=0;
                tar[i*3]=end.x; tar[i*3+1]=end.y; tar[i*3+2]=end.z;
                
                const scatDir = new THREE.Vector3().randomDirection().multiplyScalar(PARAMS.scatterSize);
                scat[i*3]=scatDir.x; scat[i*3+1]=scatDir.y; scat[i*3+2]=scatDir.z;

                const isGold = Math.random() > 0.8;
                const c = new THREE.Color(isGold ? 0xffdf00 : 0x00ffaa);
                col[i*3]=c.r; col[i*3+1]=c.g; col[i*3+2]=c.b;
            }

            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            geo.setAttribute('target', new THREE.BufferAttribute(tar, 3));
            geo.setAttribute('scatter', new THREE.BufferAttribute(scat, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(col, 3));

            particles = new THREE.Points(geo, new THREE.PointsMaterial({
                size: 0.32, map: sprite, vertexColors: true, transparent: true, opacity: 0.65,
                blending: THREE.AdditiveBlending, depthWrite: false
            }));
            scene.add(particles);

            const composer_setup = new EffectComposer(renderer);
            composer_setup.addPass(new RenderPass(scene, camera));
            composer_setup.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.77, 0.4, 0.1));
            composer = composer_setup;

            await setupCamera();
            await setupMediaPipe();
            animate();
        }

        function getTurtlePoint(i) {
            const p = i / count;
            let x, y, z;
            if (p < 0.65) { 
                const u = Math.random() * Math.PI * 2, v = Math.random() * Math.PI * 0.5;
                const r = 10;
                x = r * Math.cos(u) * Math.sin(v);
                y = r * 0.55 * Math.cos(v);
                z = r * 1.1 * Math.sin(u) * Math.sin(v);
            } else if (p < 0.8) { 
                const u = Math.random() * Math.PI * 2, v = Math.random() * Math.PI;
                const r = 2.4;
                x = r * Math.cos(u) * Math.sin(v); y = r * Math.cos(v) + 1.2; z = 13 + r * Math.sin(v);
            } else { 
                const side = Math.random() > 0.5 ? 1 : -1, front = Math.random() > 0.5 ? 1 : -1;
                x = (9 + Math.random() * 5) * side; y = -1.5; z = (front > 0 ? 8 : -8) + Math.random() * 2;
            }
            return { x, y: y + PARAMS.yOffset, z: z - 6 };
        }

        async function setupCamera() {
            video = document.getElementById('webcam');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: currentFacingMode } 
                });
                video.srcObject = stream;
                return new Promise(resolve => video.onloadedmetadata = resolve);
            } catch (err) {
                console.error("无法访问摄像头: ", err);
                alert("摄像头启动失败，请确保已授权并使用 HTTPS 访问。");
            }
        }

        async function setupMediaPipe() {
            const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0');
            const fileset = await vision.FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await vision.HandLandmarker.createFromOptions(fileset, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task" },
                runningMode: "VIDEO", numHands: 1
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if (handLandmarker && video.readyState >= 2) {
                const results = handLandmarker.detectForVideo(video, performance.now());
                if (results.landmarks?.length > 0) {
                    const pts = results.landmarks[0];
                    currentMode = (pts[12].y > pts[9].y) ? 'TREE' : 'SCATTER';
                    
                    // 获取食指指尖位置 (pts[8])
                    // 如果是后置摄像头，可能需要反转控制逻辑以符合手势方向
                    const factor = currentFacingMode === 'user' ? 1 : -1;
                    const targetRotY = (pts[8].x - 0.5) * 3.51 * factor; 
                    const targetRotX = (pts[8].y - 0.5) * 3.74;

                    particles.rotation.y += (targetRotY - particles.rotation.y) * 0.15;
                    particles.rotation.x += (targetRotX - particles.rotation.x) * 0.15;
                }
            }

            const pArr = particles.geometry.attributes.position.array;
            const tArr = particles.geometry.attributes.target.array;
            const sArr = particles.geometry.attributes.scatter.array;

            for(let i=0; i<count; i++) {
                const idx = i*3;
                if(currentMode === 'TREE') {
                    pArr[idx] += (tArr[idx] - pArr[idx]) * 0.15;
                    pArr[idx+1] += (tArr[idx+1] + Math.sin(time*2+i*0.1)*0.1 - pArr[idx+1]) * 0.15;
                    pArr[idx+2] += (tArr[idx+2] - pArr[idx+2]) * 0.15;
                } else {
                    pArr[idx] += (sArr[idx] - pArr[idx]) * PARAMS.lerpSpeed;
                    pArr[idx+1] += (sArr[idx+1] - pArr[idx+1]) * PARAMS.lerpSpeed;
                    pArr[idx+2] += (sArr[idx+2] - pArr[idx+2]) * PARAMS.lerpSpeed;
                }
            }
            particles.geometry.attributes.position.needsUpdate = true;
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
